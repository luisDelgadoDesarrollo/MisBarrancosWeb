/* tslint:disable */
/* eslint-disable */
/**
 * Swagger CanyoningApp - OpenAPI 3.0
 * Swagger of canyoning app
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: delgadofernandez.luis@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import type { ActivityType, MessageIn, MessageOut } from '../models/index'
import {
  ActivityTypeFromJSON,
  ActivityTypeToJSON,
  MessageInFromJSON,
  MessageInToJSON,
  MessageOutFromJSON,
  MessageOutToJSON,
} from '../models/index'

export interface DeleteMessageRequest {
  messageId: number
  activityType: ActivityType
}

export interface GetMessagesRequest {
  activityType: ActivityType
  activityId: number
  page?: number
  size?: number
  sort?: string
}

export interface PostMessageRequest {
  messageIn: MessageIn
}

export interface UpdateMessageRequest {
  messageId: number
  messageIn: MessageIn
}

/**
 *
 */
export class MessageApi extends runtime.BaseAPI {
  /**
   * Delete a message
   * Delete a message
   */
  async deleteMessageRaw(
    requestParameters: DeleteMessageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['messageId'] == null) {
      throw new runtime.RequiredError(
        'messageId',
        'Required parameter "messageId" was null or undefined when calling deleteMessage().',
      )
    }

    if (requestParameters['activityType'] == null) {
      throw new runtime.RequiredError(
        'activityType',
        'Required parameter "activityType" was null or undefined when calling deleteMessage().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/message/{messageId}/activityType/{activityType}`
          .replace(`{${'messageId'}}`, encodeURIComponent(String(requestParameters['messageId'])))
          .replace(
            `{${'activityType'}}`,
            encodeURIComponent(String(requestParameters['activityType'])),
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete a message
   * Delete a message
   */
  async deleteMessage(
    requestParameters: DeleteMessageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.deleteMessageRaw(requestParameters, initOverrides)
  }

  /**
   * Get all message about an activity
   * Get all message about an activity
   */
  async getMessagesRaw(
    requestParameters: GetMessagesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<MessageOut>>> {
    if (requestParameters['activityType'] == null) {
      throw new runtime.RequiredError(
        'activityType',
        'Required parameter "activityType" was null or undefined when calling getMessages().',
      )
    }

    if (requestParameters['activityId'] == null) {
      throw new runtime.RequiredError(
        'activityId',
        'Required parameter "activityId" was null or undefined when calling getMessages().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['page'] != null) {
      queryParameters['page'] = requestParameters['page']
    }

    if (requestParameters['size'] != null) {
      queryParameters['size'] = requestParameters['size']
    }

    if (requestParameters['sort'] != null) {
      queryParameters['sort'] = requestParameters['sort']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/messages/{activityType}/activity/{activityId}`
          .replace(
            `{${'activityType'}}`,
            encodeURIComponent(String(requestParameters['activityType'])),
          )
          .replace(
            `{${'activityId'}}`,
            encodeURIComponent(String(requestParameters['activityId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MessageOutFromJSON))
  }

  /**
   * Get all message about an activity
   * Get all message about an activity
   */
  async getMessages(
    requestParameters: GetMessagesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<MessageOut>> {
    const response = await this.getMessagesRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Post a new message
   * Post a new message
   */
  async postMessageRaw(
    requestParameters: PostMessageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['messageIn'] == null) {
      throw new runtime.RequiredError(
        'messageIn',
        'Required parameter "messageIn" was null or undefined when calling postMessage().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/messages`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: MessageInToJSON(requestParameters['messageIn']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Post a new message
   * Post a new message
   */
  async postMessage(
    requestParameters: PostMessageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.postMessageRaw(requestParameters, initOverrides)
  }

  /**
   * Update a message
   * Update a meesage
   */
  async updateMessageRaw(
    requestParameters: UpdateMessageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['messageId'] == null) {
      throw new runtime.RequiredError(
        'messageId',
        'Required parameter "messageId" was null or undefined when calling updateMessage().',
      )
    }

    if (requestParameters['messageIn'] == null) {
      throw new runtime.RequiredError(
        'messageIn',
        'Required parameter "messageIn" was null or undefined when calling updateMessage().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/messages/{messageId}`.replace(
          `{${'messageId'}}`,
          encodeURIComponent(String(requestParameters['messageId'])),
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: MessageInToJSON(requestParameters['messageIn']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Update a message
   * Update a meesage
   */
  async updateMessage(
    requestParameters: UpdateMessageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.updateMessageRaw(requestParameters, initOverrides)
  }
}
