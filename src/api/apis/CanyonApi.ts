/* tslint:disable */
/* eslint-disable */
/**
 * Swagger CanyoningApp - OpenAPI 3.0
 * Swagger of canyoning app
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: delgadofernandez.luis@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import type { Canyon, LocationCanyon, SimpleCanyon } from '../models/index'
import {
  CanyonFromJSON,
  CanyonToJSON,
  LocationCanyonFromJSON,
  LocationCanyonToJSON,
  SimpleCanyonFromJSON,
  SimpleCanyonToJSON,
} from '../models/index'

export interface AddCanyonToFavouritesRequest {
  canyonId: number
}

export interface CreateCanyonRequest {
  canyon?: Canyon
}

export interface DeleteCanyonRequest {
  canyonId: number
}

export interface DeleteCanyonFromFavouritesRequest {
  canyonId: number
}

export interface DownloadCanyonRequest {
  canyonId: number
  email?: boolean
}

export interface GetCanyonRequest {
  canyonId: number
}

export interface GetCanyonsRequest {
  name?: string
  season?: string
  river?: string
  country?: string
  population?: string
  page?: number
  size?: number
  sort?: string
}

export interface GetFavouriteCanyonsRequest {
  name?: string
  season?: string
  river?: string
  country?: string
  population?: string
  page?: number
  size?: number
  sort?: string
}

export interface UpdateCanyonRequest {
  canyonId: number
  canyon?: Canyon
}

/**
 *
 */
export class CanyonApi extends runtime.BaseAPI {
  /**
   * Add canyon to favourites
   */
  async addCanyonToFavouritesRaw(
    requestParameters: AddCanyonToFavouritesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['canyonId'] == null) {
      throw new runtime.RequiredError(
        'canyonId',
        'Required parameter "canyonId" was null or undefined when calling addCanyonToFavourites().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/canyons/favourites/{canyonId}`.replace(
          `{${'canyonId'}}`,
          encodeURIComponent(String(requestParameters['canyonId'])),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Add canyon to favourites
   */
  async addCanyonToFavourites(
    requestParameters: AddCanyonToFavouritesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.addCanyonToFavouritesRaw(requestParameters, initOverrides)
  }

  /**
   * Create a new canyon
   * Create a new canyon
   */
  async createCanyonRaw(
    requestParameters: CreateCanyonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Canyon>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/canyons`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CanyonToJSON(requestParameters['canyon']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => CanyonFromJSON(jsonValue))
  }

  /**
   * Create a new canyon
   * Create a new canyon
   */
  async createCanyon(
    requestParameters: CreateCanyonRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Canyon> {
    const response = await this.createCanyonRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * delete a canyon
   * Deletes a canyon
   */
  async deleteCanyonRaw(
    requestParameters: DeleteCanyonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['canyonId'] == null) {
      throw new runtime.RequiredError(
        'canyonId',
        'Required parameter "canyonId" was null or undefined when calling deleteCanyon().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/canyons/{canyonId}`.replace(
          `{${'canyonId'}}`,
          encodeURIComponent(String(requestParameters['canyonId'])),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * delete a canyon
   * Deletes a canyon
   */
  async deleteCanyon(
    requestParameters: DeleteCanyonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.deleteCanyonRaw(requestParameters, initOverrides)
  }

  /**
   * delete a canyon from favourites
   * Deletes a favourite
   */
  async deleteCanyonFromFavouritesRaw(
    requestParameters: DeleteCanyonFromFavouritesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['canyonId'] == null) {
      throw new runtime.RequiredError(
        'canyonId',
        'Required parameter "canyonId" was null or undefined when calling deleteCanyonFromFavourites().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/canyons/favourites/{canyonId}`.replace(
          `{${'canyonId'}}`,
          encodeURIComponent(String(requestParameters['canyonId'])),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * delete a canyon from favourites
   * Deletes a favourite
   */
  async deleteCanyonFromFavourites(
    requestParameters: DeleteCanyonFromFavouritesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.deleteCanyonFromFavouritesRaw(requestParameters, initOverrides)
  }

  /**
   * Download canyon by id and return a PDF file
   * Download a canyon
   */
  async downloadCanyonRaw(
    requestParameters: DownloadCanyonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Blob>> {
    if (requestParameters['canyonId'] == null) {
      throw new runtime.RequiredError(
        'canyonId',
        'Required parameter "canyonId" was null or undefined when calling downloadCanyon().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['email'] != null) {
      queryParameters['email'] = requestParameters['email']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/canyons/{canyonId}/download`.replace(
          `{${'canyonId'}}`,
          encodeURIComponent(String(requestParameters['canyonId'])),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.BlobApiResponse(response)
  }

  /**
   * Download canyon by id and return a PDF file
   * Download a canyon
   */
  async downloadCanyon(
    requestParameters: DownloadCanyonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Blob> {
    const response = await this.downloadCanyonRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get canyon by id
   * Get one canyon
   */
  async getCanyonRaw(
    requestParameters: GetCanyonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Canyon>> {
    if (requestParameters['canyonId'] == null) {
      throw new runtime.RequiredError(
        'canyonId',
        'Required parameter "canyonId" was null or undefined when calling getCanyon().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/canyons/{canyonId}`.replace(
          `{${'canyonId'}}`,
          encodeURIComponent(String(requestParameters['canyonId'])),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => CanyonFromJSON(jsonValue))
  }

  /**
   * Get canyon by id
   * Get one canyon
   */
  async getCanyon(
    requestParameters: GetCanyonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Canyon> {
    const response = await this.getCanyonRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get all canyon filtering by differents fields
   * Get all canyon
   */
  async getCanyonsRaw(
    requestParameters: GetCanyonsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<SimpleCanyon>>> {
    const queryParameters: any = {}

    if (requestParameters['name'] != null) {
      queryParameters['name'] = requestParameters['name']
    }

    if (requestParameters['season'] != null) {
      queryParameters['season'] = requestParameters['season']
    }

    if (requestParameters['river'] != null) {
      queryParameters['river'] = requestParameters['river']
    }

    if (requestParameters['country'] != null) {
      queryParameters['country'] = requestParameters['country']
    }

    if (requestParameters['population'] != null) {
      queryParameters['population'] = requestParameters['population']
    }

    if (requestParameters['page'] != null) {
      queryParameters['page'] = requestParameters['page']
    }

    if (requestParameters['size'] != null) {
      queryParameters['size'] = requestParameters['size']
    }

    if (requestParameters['sort'] != null) {
      queryParameters['sort'] = requestParameters['sort']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/canyons`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SimpleCanyonFromJSON))
  }

  /**
   * Get all canyon filtering by differents fields
   * Get all canyon
   */
  async getCanyons(
    requestParameters: GetCanyonsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<SimpleCanyon>> {
    const response = await this.getCanyonsRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get all canyon filtering by differents fields
   * Get all canyon
   */
  async getFavouriteCanyonsRaw(
    requestParameters: GetFavouriteCanyonsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<SimpleCanyon>>> {
    const queryParameters: any = {}

    if (requestParameters['name'] != null) {
      queryParameters['name'] = requestParameters['name']
    }

    if (requestParameters['season'] != null) {
      queryParameters['season'] = requestParameters['season']
    }

    if (requestParameters['river'] != null) {
      queryParameters['river'] = requestParameters['river']
    }

    if (requestParameters['country'] != null) {
      queryParameters['country'] = requestParameters['country']
    }

    if (requestParameters['population'] != null) {
      queryParameters['population'] = requestParameters['population']
    }

    if (requestParameters['page'] != null) {
      queryParameters['page'] = requestParameters['page']
    }

    if (requestParameters['size'] != null) {
      queryParameters['size'] = requestParameters['size']
    }

    if (requestParameters['sort'] != null) {
      queryParameters['sort'] = requestParameters['sort']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/canyons/favourites`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SimpleCanyonFromJSON))
  }

  /**
   * Get all canyon filtering by differents fields
   * Get all canyon
   */
  async getFavouriteCanyons(
    requestParameters: GetFavouriteCanyonsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<SimpleCanyon>> {
    const response = await this.getFavouriteCanyonsRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get location from canyons
   * Get Locations
   */
  async getLocationsRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<LocationCanyon>>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/canyons/map`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(LocationCanyonFromJSON),
    )
  }

  /**
   * Get location from canyons
   * Get Locations
   */
  async getLocations(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<LocationCanyon>> {
    const response = await this.getLocationsRaw(initOverrides)
    return await response.value()
  }

  /**
   * Update your canyon
   * Update your canyon
   */
  async updateCanyonRaw(
    requestParameters: UpdateCanyonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Canyon>> {
    if (requestParameters['canyonId'] == null) {
      throw new runtime.RequiredError(
        'canyonId',
        'Required parameter "canyonId" was null or undefined when calling updateCanyon().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password)
    }
    const response = await this.request(
      {
        path: `/canyons/{canyonId}`.replace(
          `{${'canyonId'}}`,
          encodeURIComponent(String(requestParameters['canyonId'])),
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: CanyonToJSON(requestParameters['canyon']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => CanyonFromJSON(jsonValue))
  }

  /**
   * Update your canyon
   * Update your canyon
   */
  async updateCanyon(
    requestParameters: UpdateCanyonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Canyon> {
    const response = await this.updateCanyonRaw(requestParameters, initOverrides)
    return await response.value()
  }
}
